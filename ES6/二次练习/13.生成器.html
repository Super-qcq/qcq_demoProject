<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。
  生成器函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同；
  上面代码就是一个 Generator 函数。它不同于普通函数，是可以暂停执行的，所以函数名之前要加星号，以示区别。
  整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。Generator 函数的执行方法如下。
  var g = gen(1);
  g.next() // { value: 3, done: false }
  g.next() // { value: undefined, done: true }
  上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器 ）g 。
  这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。
  第二个next()括号里面的参数是第一个yield语句的返回值。
  调用指针 g 的 next 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 yield 语句，
  上例是执行到 x + 2 为止。
  换言之，next 方法的作用是分阶段执行 Generator 函数。
  每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。
  value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，
  表示 Generator 函数是否执行完毕，即是否还有下一个阶段。
  六、Generator 函数的数据交换和错误处理
  Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。
  next 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据。
  生成器其实就是一个特殊的函数            
  异步编程  纯回调函数  node fs  ajax mongodb            
  yield：函数代码的分隔符
  <script>
    function * gen(){
      let result1 = yield 'qcq'
      console.log(result1)
      let result2 = yield 'lct'
      console.log(result2)
      let result3 = yield 'lr'
      console.log(result3)
    }
    let g = gen()
    console.log(g.next())
    console.log(g.next('111'))
    console.log(g.next('222'))
    console.log(g.next('333'))
  </script>
</body>
</html>